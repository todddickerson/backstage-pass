# Team vs Space Architecture Decision

## ðŸŽ¯ Decision: Team has_many Spaces (with simplified UX)

**We architecturally support Team has_many Spaces BUT simplify the UX to act like one-to-one initially.**

## Why This Approach?

### 1. Bullet Train Framework Compliance
- Bullet Train expects Teams as the billing/authorization context
- All scaffolding and authorization flows through Teams
- Changing this would require massive framework customization

### 2. Future Flexibility Without Breaking Changes
- Database supports multiple Spaces from day one
- Can enable multi-brand creators without migrations
- Similar to Shopify's evolution (one store â†’ multiple stores for Plus)

### 3. Clean Public URLs
```ruby
# What users see:
backstagepass.app/creator-name         # Space public page
backstagepass.app/@username            # Creator profile

# What happens internally:
Space.friendly.find("creator-name")    # Uses FriendlyId
Team â†’ Space relationship maintained    # For billing/auth
```

### 4. Proper Separation of Concerns
- **Team**: Billing, members, subscription, account settings
- **Space**: Content, experiences, public presence, branding
- **CreatorProfile**: Public bio, social links (belongs to User, not Team)

## Implementation Guide

### Phase 1: One Space Per Team (Current)

```ruby
# app/models/team.rb
class Team < ApplicationRecord
  include Teams::Base  # Bullet Train
  
  # Looks like has_one to the app, but is has_many underneath
  has_one :space, dependent: :destroy
  
  # Auto-create Space when Team created
  after_create :create_default_space
  
  # Helper to always get a Space
  def primary_space
    space || create_space!(
      name: name,
      slug: slug.presence || name.parameterize
    )
  end
  
  private
  
  def create_default_space
    create_space!(
      name: name,
      slug: slug.presence || name.parameterize,
      description: "Welcome to #{name}'s space"
    )
  end
end

# app/models/space.rb
class Space < ApplicationRecord
  include Spaces::Base  # Generated by super_scaffold
  
  belongs_to :team
  
  # CRITICAL: Enforce one space per team for now
  validates :team_id, uniqueness: true
  
  # Pretty URLs
  extend FriendlyId
  friendly_id :slug, use: :slugged
  
  # Must be unique across platform
  validates :slug, uniqueness: true
  
  # Marketplace relationships
  has_many :experiences, dependent: :destroy
  has_many :access_passes
end
```

### UI/UX Simplifications

#### Admin Navigation
```erb
<!-- app/views/account/shared/_menu.html.erb -->
<!-- Instead of "Spaces" plural -->
<%= link_to "Your Space", account_space_path(current_team.primary_space) %>

<!-- Not this -->
<%= link_to "Your Spaces", account_team_spaces_path(current_team) %>
```

#### Routes Configuration
```ruby
# config/routes.rb
Rails.application.routes.draw do
  # Public routes - clean URLs
  get '@:username', to: 'public/creator_profiles#show', as: :creator_profile
  get ':space_slug', to: 'public/spaces#show', as: :public_space
  get ':space_slug/:pass_slug', to: 'public/access_passes#show'
  
  # Account routes - simplified
  namespace :account do
    # Singular resource for the one Space
    resource :space do
      resources :experiences
      resources :access_passes
    end
    
    # Team settings separate
    resources :teams do
      member do
        # Billing, members, etc.
      end
    end
  end
  
  # Member experience routes
  namespace :account do
    resources :purchased_spaces, only: [:index, :show] do
      resources :experiences, only: [:show] do
        member do
          get :stream
        end
      end
    end
  end
end
```

#### Controller Simplification
```ruby
# app/controllers/account/spaces_controller.rb
class Account::SpacesController < Account::ApplicationController
  # Treat as singular resource
  before_action :set_space
  
  private
  
  def set_space
    # Always get the one space for this team
    @space = current_team.primary_space
  end
end
```

### Phase 2: Multiple Spaces (Future)

When ready to support multiple Spaces per Team:

```ruby
# Migration
class EnableMultipleSpacesPerTeam < ActiveRecord::Migration[8.0]
  def change
    # Remove uniqueness constraint
    remove_index :spaces, :team_id
    add_index :spaces, :team_id
    
    # Add primary flag
    add_column :spaces, :primary, :boolean, default: false
    add_index :spaces, [:team_id, :primary]
    
    # Mark existing spaces as primary
    Space.update_all(primary: true)
  end
end

# Updated Team model
class Team < ApplicationRecord
  has_many :spaces, dependent: :destroy  # Changed from has_one
  
  def primary_space
    spaces.primary.first || spaces.first
  end
end

# Updated Space model  
class Space < ApplicationRecord
  belongs_to :team
  
  # Remove this line:
  # validates :team_id, uniqueness: true
  
  # Add this:
  validates :team_id, uniqueness: { scope: :primary }, if: :primary?
  
  scope :primary, -> { where(primary: true) }
end
```

## Common Implementation Patterns

### Getting the Space in Controllers
```ruby
# For current team's space
@space = current_team.primary_space

# For public pages
@space = Space.friendly.find(params[:space_slug])

# For purchased content
@space = current_user.purchased_spaces.friendly.find(params[:id])
```

### Checking Access
```ruby
# Can user manage this space?
can?(:manage, @space)  # Uses Team-based permissions

# Does user have access to view?
current_user.access_passes.active.where(space: @space).exists?
```

### Creating Related Objects
```ruby
# Always through the Space
@experience = @space.experiences.build(experience_params)
@access_pass = @space.access_passes.build(access_pass_params)
```

## Mental Models for Different Users

### For Creators
- "I have an account" (Team)
- "I have a storefront" (Space) 
- "I sell passes" (AccessPasses)
- "I create experiences" (Experiences)

### For Buyers
- "I follow creators" (CreatorProfiles)
- "I visit their space" (Spaces)
- "I buy access" (AccessPasses) 
- "I enjoy experiences" (Experiences)

### For Developers
- Team owns Space (1:1 initially, 1:many later)
- Space owns Experiences and AccessPasses
- AccessPass grants access to selected Experiences
- All authorization flows through Team context

## Testing Considerations

```ruby
# factories/teams.rb
FactoryBot.define do
  factory :team do
    name { Faker::Company.name }
    
    trait :with_space do
      after(:create) do |team|
        # Will auto-create via callback
      end
    end
  end
end

# In tests
let(:team) { create(:team) }  # Automatically has space
let(:space) { team.primary_space }  # Always available
```

## Key Takeaways

1. **Database**: Supports many Spaces per Team from day one
2. **Validation**: Enforces one Space per Team initially  
3. **UI**: Treats it as singular ("Your Space" not "Spaces")
4. **URLs**: Clean public routes hide Team concept
5. **Future**: Remove validation to enable multiple Spaces
6. **Billing**: Always happens at Team level (Bullet Train standard)
7. **Content**: Always scoped to Space level

This architecture gives us maximum flexibility with minimum initial complexity. Creators get a simple experience while we maintain the ability to expand features without breaking changes.